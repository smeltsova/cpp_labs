# Задача № 4

В задаче №3 вы реализовали простой шаблон `ValueHolder`, в этом задании мы используем его чтобы написать класс `Any` (интересно, что не шаблонный), который позволяет хранить значения любого типа. Например, вы сможете  создать массив объектов типа `Any`, и сохранять в них `int`-ы, `double`-ы или даже объекты `Array`. Подробности в шаблоне кода.

**Подсказка:** в нешаблонном классе Any могут быть шаблонные методы, например, шаблонный конструктор.

Для реализации вам может потребоваться оператор `dynamic_cast` (см. ниже).

```cpp=
// Это класс, который вам нужно реализовать
class Any
{
public:
    // В классе Any должен быть конструктор,
    // который можно вызвать без параметров,
    // чтобы работал следующий код:
    //    Any empty; // empty ничего не хранит

    // В классе Any должен быть шаблонный
    // конструктор от одного параметра, чтобы
    // можно было создавать объекты типа Any,
    // например, следующим образом:
    //    Any i(10); // i хранит значение 10
 
    // В классе Any также должен быть конструктор
    // копирования (вам поможет метод clone
    // интерфейса ICloneable)
    
    // Не забудьте про деструктор. Все выделенные
    // ресурсы нужно освободить.
 
    // В классе должен быть оператор присваивания и/или
    // шаблонный оператор присваивания, чтобы работал
    // следующий код:
    //    Any copy(i); // copy хранит 10, как и i
    //    empty = copy; // empty хранит 10, как и copy
    //    empty = 0; // а теперь empty хранит 0

    // Ну и наконец, мы хотим уметь получать хранимое
    // значение, для этого определите в классе Any
    // шаблонный метод cast, который возвращает
    // указатель на хранимое значение, или нулевой
    // указатель в случае несоответствия типов или
    // если объект Any ничего не хранит:
    //    int *iptr = i.cast<int>(); // *iptr == 10
    //    char *cptr = i.cast<char>(); // cptr == 0,
    //        // потому что i хранит int, а не char
    //    Any empty2;
    //    int *p = empty2.cast<int>(); // p == 0
    // При реализации можете использавать оператор dynamic_cast (см. ниже).
private:
    // Поля и дополнительные методы определите сами
};

```

Про `dynamic_cast`:

Допустим у вас есть два наследника класса `Base`: `Derived1` и `Derived2`. Кроме того у вас есть указать `baseptr` типа `Base*`. Как проверить указывает ли этот указатель на
самом деле на объект класса `Derived1` или на объект класса `Derived2`? Для этого можно воспользоваться `dynamic_cast`-ом:
```cpp=
Derived1 *derived1ptr = dynamic_cast<Derived1*>(baseptr);
```
Если `derived1ptr` не равен 0, то  baseptr на самом деле указывал на объект класса `Derived1`, если же `derivedptr` равен 0, то baseptr на самом деле указывал на объкт какого-то другого класса (например, `Derived2`). Это можно проверить так:
```cpp=
Derived2 *derived2ptr = dynamic_cast<Derived2*>(baseptr);
```
`dynamic_cast` работает только, если в классе есть хотя бы один виртуальный метод, и в шаблоне `ValueHolder` такой как раз имеется.
